# 기본 공통 설정
spring:
  application:
    name: market-Back

  ai:
    openai:
      api-key: ${OPENAI_API_KEY:${OPENAI_API_KEY_DEFAULT}}
      base-url: https://api.openai.com
      chat:
        model: gpt-4.1-nano
        options:
          temperature: 0.5
          max-tokens: 480

  jpa:
    open-in-view: false
    properties:
      hibernate:
        format_sql: true
        use_sql_comments: true
        dialect: org.hibernate.dialect.MySQL8Dialect

  servlet:
    multipart:
      enabled: true
      max-file-size: 5MB
      max-request-size: 10MB

  profiles:
    active: dev

  # AWS 설정
  cloud:
    aws:
      region:
        static: ap-northeast-2
      credentials:
        accessKey: ${AWS_ACCESSKEY:${AWS_ACCESSKEY_DEFAULT}}
        secretKey: ${AWS_SECRETKEY:${AWS_SECRETKEY_DEFAULT}}
      s3:
        bucket: ${AWS_BUCKET_NAME:${AWS_BUCKET_NAME_DEFAULT}}

  # OAuth -> ???? ???? ???..
  google:
    oauth:
      client-id: ${OAUTH_GOOGLE_CLIENT_ID:${OAUTH_GOOGLE_CLIENT_ID_DEFAULT}}
      client-secret: ${OAUTH_GOOGLE_CLIENT_SECRET:${OAUTH_GOOGLE_CLIENT_SECRET_DEFAULT}}

  # JWT ?? -> ???? ???? ???..
  external:
    jwt:
      token:
        prefix: "Bearer "
        access-token: Authorization
        refresh-token: Refresh-Token
        expiration: Access-Token-Expire-Time
      access:
        prefix: Authorization
        secret: ${JWT_ACCESS_SECRET:${JWT_ACCESS_SECRET_DEFAULT}}
        expiration-ms: 900000      # 15?
      refresh:
        prefix: refreshToken
        secret: ${JWT_REFRESH_SECRET:${JWT_REFRESH_SECRET_DEFAULT}}
        expiration-ms: 604800000   # 7?

  server:
    port: 8080
    servlet:
      context-path: /api
    forward-headers-strategy: framework

---
# dev 개발 환경 (data.sql이 모든 것을 처리하도록 수정됨)
spring:
  config:
    import: optional:file:.env[.properties]
    activate:
      on-profile: dev

  # === H2 데이터베이스 설정 (변경 없음) ===
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
    username: sa
    password:

  # === JPA 설정 변경 ===
  jpa:
    hibernate:
      # ddl-auto: create-drop  <- 이 설정을 'none'으로 변경합니다.
      ddl-auto: none # 이제 JPA가 테이블을 건드리지 않고, data.sql이 모든 DDL을 처리합니다.
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.H2Dialect
        format_sql: true
        use_sql_comments: true

  # === H2 웹 콘솔 활성화 (변경 없음) ===
  h2:
    console:
      enabled: true
      path: /h2-console

  # === SQL 스크립트 실행 설정 추가 ===
  sql:
    init:
      mode: always # 항상 data.sql 스크립트를 실행하도록 명시

# CORS ??
cors:
  allowed-origins: http://localhost:3000, ${FRONTEND_DOMAIN:https://market-frontend.netlify.app}

# OAuth Redirect URI -> ??? ?? ??.
google:
  oauth:
    redirect-uri: ${REDIRECT_URI:http://localhost:8080/api/auth/callback}

# ?? ?? (?? ?? ???? ?? ???.)
logging:
  level:
    root: INFO
    org.example.marketback: INFO
    org.springframework.security: DEBUG
    org.springframework.web.servlet: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
    org.springframework.web.client.RestTemplate: DEBUG
    org.hibernate.type: trace
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"

# ????? ?? ??.
management:
  endpoints:
    web:
      exposure:
        include: "*"
  endpoint:
    health:
      show-details: always

---
# docker == production mode (수정 없음)
spring:
  config:
    activate:
      on-profile: prod
  # ... (prod 프로파일 내용은 변경되지 않았습니다) ...